webpackJsonp([10],{a7Hy:function(n,e,t){n.exports=t("nYVP")},ftrg:function(n,e,t){"use strict";var a=function(){var n=this,e=n.$createElement;n._self._c;return n._m(0)},r=[function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("section",[t("p",[n._v('{\n"title": "JavaScript对象属性排序",\n"path":"JavaScript",\n"tags": ["JavaScript"],\n"categories": "笔记",\n"date": "2017-10-19",\n"desc": "JavaScript对象属性排序问题",\n"cover": "http://s2.51cto.com/wyfs02/M00/8B/CF/wKiom1hZLQezjl7nAADTxc8C9A8143.jpg"\n}')]),n._v(" "),t("h1",[n._v("JavaScript对象属性排序")]),n._v(" "),t("hr"),n._v(" "),t("h2",[n._v("对象解释")]),n._v(" "),t("blockquote",[t("p",[n._v("对象是Object类型的成员。它是一个无序的属性集合，每个属性都包含一个原始值，对象或函数。存储在对象的属性中的函数称为方法。所以JavaScript中不能保证对象中的属性顺序，需要用数组的方式解决顺序问题。映射以插入顺序迭代其元素，而不为对象指定迭代顺序。")])]),n._v(" "),t("h3",[n._v("解决问题")]),n._v(" "),t("p",[n._v("文章对象按时间倒叙排列")]),n._v(" "),t("h3",[n._v("实例")]),n._v(" "),t("h4",[n._v("原函数")]),n._v(" "),t("pre",{pre:!0},[t("code",{attrs:{"v-pre":""}},[n._v("const articlesArr = [\n  {\n    date: '2017-07-13',\n    name: 'xxx'\n  },\n  {\n    date: '2017-09-21',\n    name: 'yyy'\n  },\n  {\n    date: '2016-06-03',\n    name: 'zzz'\n  },\n  {\n    date: '2015-02-13',\n    name: 'vvv'\n  },\n]\nconst time = ['2017','2016','2015']\nlet archives = {}\nfor (let i = 0, _len = time.length; i < _len; i++) {\n  archives[time[i]] = []\n  for (let j = 0, _len = articlesArr.length; j < _len; j++) {\n    if (time[i] === articlesArr[j].date.substring(0, 4)) {\n      archives[time[i]].push(articlesArr[j])\n    }\n  }\n}\nconsole.log(archives)\n//  结果并不是期望的从2017开始排序，并且2017的数组对象也不是按时间倒叙\narchives = {\n  2015: [\n    {date: \"2015-02-13\", name: \"vvv\"}\n  ],\n  2016: [\n    {date: \"2016-06-03\", name: \"zzz\"}\n  ],\n  2017: [\n    {date: \"2017-07-13\", name: \"xxx\"},\n    {date: \"2017-09-21\", name: \"yyy\"}\n  ]\n}\n")])]),n._v(" "),t("h4",[n._v("解决方案")]),n._v(" "),t("pre",{pre:!0},[t("code",{attrs:{"v-pre":""}},[n._v('let archivesArr = []  //  存放的数组\nfor (let i = 0, _len = time.length; i < _len; i++) {\n  archives[time[i]] = []\n  for (let j = 0, _len = articlesArr.length; j < _len; j++) {\n    if (time[i] === articlesArr[j].date.substring(0, 4)) {\n      archives[time[i]].push(articlesArr[j])\n    }\n  }\n  archives[time[i]].sort(function (a, b) {  // 对每个对象中数组内的值按时间倒叙\n    return Date.parse(b.date) - Date.parse(a.date)\n  })\n  archivesArr.unshift(archives[time[i]]) //  再将原对象的属性值按序添加到数组\n}\nconsole.log(archivesArr)\n//  2017的数组对象已按按时间倒叙\narchives = {\n  2015: [\n    {date: "2015-02-13", name: "vvv"}\n  ],\n  2016: [\n    {date: "2016-06-03", name: "zzz"}\n  ],\n  2017: [\n    {date: "2017-09-21", name: "xxx"},\n    {date: "2017-07-13", name: "yyy"}\n  ]\n}\n// archivesArr是期望的按时间顺序倒叙\narchivesArr = [\n  [\n    {date: "2017-09-21", name: "yyy"},\n    {date: "2017-07-13", name: "xxx"}\n  ],\n  [\n    {date: "2016-06-03", name: "zzz"}\n  ],\n  [\n    {date: "2015-02-13", name: "vvv"}\n  ]\n]\n')])])])}],i={render:a,staticRenderFns:r};e.a=i},nYVP:function(n,e,t){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var a=t("ftrg"),r=t("46Yf"),i=r(null,a.a,!1,null,null,null);e.default=i.exports}});